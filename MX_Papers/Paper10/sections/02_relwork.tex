\section{Related Work}
\label{sec::sota}

Portability, interoperability, configurability, and distribution across devices are key goals of IEC~61499 \cite{jhunjhunwala2024interoperability,hopsu2019portability, batchkova2013dynamic}. 
This has led to its application in use cases of flexible manufacturing systems, such as multi-agent systems \cite{lyu2023multi, xavier2024enhancing}. However, portability between vendors has not yet been achieved due to vendor-specific execution behaviour \cite{misperceptions}. In this section, we therefore review recent studies on porting software between engineering platforms. Furthermore, techniques for improving the reliability of control software are discussed with a focus on testing approaches. The approach proposed in this paper aims to test software components on different platforms, thus, promoting reusability of software as well as supporting the process of porting software components. 

\subsection{Portability of Control Software}
Both standards that define programming languages for control software, i.e., IEC~61131-3 \cite{61131.3} and IEC~61499-1 \cite{61499}, define XML formats for exchanging software between PLC environments \cite{61131.10,plcopenpaper, 61499.2, Testing_Midhun}. The standardised format contributes to code exchange between tools from different vendors~\cite{plcopenpaper}. As existing tools only support a varying subset of features, portability is limited in practice \cite{Testing_Midhun}. Certain vendors also use custom XML tags to store additional information in their projects which are not covered by the standard itself, such as namespaces in IEC~61499. The resulting software may still be portable if the parser in the target IDE discards unknown XML tags that carry additional information \cite{Hopsu.2019}.  The language specification focusses on control software without detailing applied communication standards or visualisation options. Language extensions, such as modelling elements for communication \cite{Bruns.2023}, are not widely supported and therefore not yet portable. One of the IDEs allows specifying the human-machine interaction (HMI) as part of the control code with dedicated blocks, so-called CAT elements \cite{Hopsu.2019}. Converter programs can help translate programs between syntactic variants of IEC~61499 \cite{Hopsu.2019}, but vendor-specific extensions can typically not be transferred. 
Even syntactic equivalence does not guarantee portability. Nowadays, cross-platform development does not require porting because a single IDE allows deploying software to multiple run-time environments \cite{aimirimi}. 
The IEC~61499 language semantics is not specified formally and is subject to interpretation. Different execution semantics have emerged, which can affect the behaviour of the cyber-physical system \cite{cengic_executionsemantics}. Hence, migrating IEC~61499-based software to different run-time environments can introduce errors that may cause damage to operators or equipment. While the syntactic portability has been addressed \cite{Hopsu.2019,Testing_Midhun}, different execution behaviours cannot yet be detected (semi-)automatically. It is therefore crucial to thoroughly test IEC~61499 applications in the target platform before deployment. Existing testing mechanisms enable systematically evaluating the implemented execution semantics of IEC~61499 runtime environments \cite{Wiesmayr.2023,pfefferkorn,Testing_Midhun}, but a solution for porting test cases including their execution framework to different platforms is not yet available. We have presented our initial concept in \cite{biancaMidhunETFAwip}. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Validating Control Software}
%\todo[inline]{Add references and details}
Cengic and Akesson~\cite{cengic_executionsemantics} followed the approach of creating a formal semantics specification for each runtime environment. Subsequently, formal verification methods can be applied to identify errors in the code \cite{xavier2024framework}, which can enhance a system's reliability by checking various properties. Formal verification does not require access to any RTE, but a model of the execution behaviour is required. Sinha et al.~\cite{Sinha.2019} provide an overview of formal methods for IEC~61499. Formal verification may uncover errors that do not occur during simulations, thus, identifying certain undesirable situations \cite{lilli2023formal}. 
Control software has to be continuously adapted to changing requirements. Research has therefore provided guidance on the correct evolution of control software developed in IEC~61499 \cite{faqrizal_guidedevolution}. 
Verification and testing can complement each other \cite{Hussain.2006}. During development, tests provide early feedback, even if the model is still incomplete. Furthermore, errors that are introduced during the deployment may lead to issues encountered during runtime, but might not be revealed by formal methods \cite{ovsiannikova2023formal} \cite{xavier2023formal}. Hence, testing deployed software directly in the run-time environment remains valuable.
%Simulation techniques such as visualisations or Digital Twins are commonly employed to assess whether a control application operates according to the intended logic. However, relying on a simulation does not ensure correctness, as some malfunctions may occur only on a PLC. Finally, simulations can also aid in comprehending the system's behaviour.

Developers can apply various testing strategies, which we differentiate based on the involved software activities (e.g., unit tests or integration tests), the maturity of the software, and the degree of automation~\cite{softwareTesting}. 
Unit testing is a fundamental approach to software testing, which evaluates the implementation of a piece of software \cite{softwareTesting} to ensure software reliability.
In IEC~61499, the relevant units are individual Function Blocks (FBs) \cite{hametner2014}. Executing a test requires providing event and data signals. For control engineers who develop FBs, it can be challenging to manually create a test FB and the required test application, which derives and collects the test results. Model-based testing can reduce manual effort and also supports a ``test first and fail'' methodology, known as Test-Driven Development (TDD) \cite{hametner2014}, which is used in agile software engineering.  
After developing the control program for the entire system, functional tests can be conducted. This involves evaluating the control system by providing input data and verifying the output against expected results.

Tools should support engineers in specifying test cases to reduce the required software engineering knowledge and increase efficiency \cite{hametner2014}. Model-based testing involves automating at least part of the testing activities. For IEC~61499 FBs, service sequences are suitable for specifying tests \cite{hametner2014}. 
% TODO describe here in related work existing work on model-based testing or sth like that?? shift our new work to the beginning of the next section
A test runner can execute these tests in an RTE and automatically evaluate the results \cite{hametner2014}. Additionally, executing models directly can allow feedback without involving any RTE and is also feasible for service sequences \cite{wiesmayr2021}. The former approach requires specific tool support for a certain RTE, the latter cannot provide feedback regarding issues introduced in the deployment to an RTE. Our approach builds upon these works. 
As an alternative to service sequences, UML models have been used as test specifications \cite{Hussain.2006}. From a state-based model, test cases can be derived using coverage-driven algorithms \cite{Hussain.2006}. Using an evolutionary algorithm, test cases with a high coverage were generated directly from the FB model in \cite{Buzhinsky.2015}. Test case generation can augment our approach, which focusses on executing tests of any source on multiple platforms. Additional tool support would be required to use other test specifications than service sequences.
%In this approach, a test specification is created as service sequences to test the developed IEC 61499 function block with control logic. However, this approach is executed in the interpreter and does not have runtime support. The results are compared to the output of the sequence primitive.

Two major problems are still associated with developing distributed control software that spans multiple platforms: 
\begin{itemize}
    \item The \emph{lack of automated tool support for RTE comparison} makes comparing the behaviour and performance of FBs across different RTEs a challenging task. Currently, manual comparison is time-consuming and error-prone. Dedicated tools should analyse and evaluate the behaviour of FBs in different RTEs to ensure an accurate comparison.
    \item \emph{Software development for different RTEs} is challenging because the compatibility and portability of an FB across different RTEs cannot be assumed.
\end{itemize}
For example, if an FB is initially developed and tested on one RTE, such as SE EcoRT, there might be a need to reuse that FB in another project in a different RTE, such as 4diac FORTE. Differences in RTE behaviour, programming languages, and underlying architectures can cause compatibility issues and hinder the seamless transfer of FBs between different RTEs. 

\subsection{Cross-Platform Tests of Control Software}
Two main strategies are relevant for IEC~61499-based software. Firstly, \textbf{manually created test FBs} \cite{Testing_Midhun} can reveal the behaviour implemented in an RTE. Each test FB encompasses multiple test scenarios and embeds control logic. To indicate whether a test was successful, the expected result is compared with the result obtained from executing the control logic. The tests are implemented as a Basic FB with event and data pins. Each input event represents a test scenario linked to specific data inputs, while output events indicate the expected result and corresponding data outputs. When a test scenario is triggered, the state diagram (i.e., Execution Control Chart, ECC) executes an algorithm that assigns input values, generates outputs based on those values, and triggers the output event. The main purpose of these FBs was to identify differences between the execution behaviour in RTEs, not to test FB libraries. Similarly, small networks of FBs can further expand these test suites \cite{pfefferkorn,Wiesmayr.2023}. 
As a second approach, \textbf{generating test code from a high-level test specification} has the potential to enable testing FB implementations \cite{biancaMidhunETFAwip}.