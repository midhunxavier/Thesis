\section{Introduction}

Industrial automation is undergoing a significant transformation, driven by the need for mass customization, increased flexibility, and reconfigurability. This has led to the adoption of modular, distributed architectures, often termed Component-Based industrial Automation Systems (CBAS) or, more broadly, industrial Cyber-Physical Systems (iCPS) \cite{lee2017introduction}. The International Electrotechnical Commission (IEC) 61499 standard has emerged as a key enabler for engineering these complex systems, providing a vendor-independent, component-based model for distributed control applications \cite{iec61499part12012, dai2017discrete}.

However, the increased complexity and distributed nature of these systems pose significant verification and validation (V\&V) challenges \cite{vyatkin1999modeling}. Traditional V\&V techniques, such as simulation and testing, are often inadequate for ensuring the high levels of dependability, safety, and reliability required, particularly in safety-critical domains like nuclear material handling or power grid protection \cite{clarke1999, schneider2004}. While simulation is invaluable for assessing general system behavior, it cannot explore the entire state space of complex industrial software, meaning it can show the presence of bugs but not their absence \cite{clarke2000, biere2003bounded}.

To address this gap, formal methods offer a mathematically rigorous approach to system verification \cite{clarke1999}. Model checking, in particular, is an automated technique that systematically explores all reachable states of a system model to verify whether it satisfies a given set of formal specifications, typically expressed in temporal logic \cite{emerson1985decision}. Despite its power to uncover subtle design flaws that simulation might miss, the adoption of model checking in industrial practice has been limited. This is often due to challenges such as the state-space explosion problem, the need for specialized expertise to create formal models, and a lack of user-friendly tools that integrate seamlessly into the existing engineering lifecycle \cite{Buzhinsky2020, Cimatti2012}.

This chapter presents an integrated, model-based framework designed to bridge this gap \cite{vyatkin2008closed}. It leverages the IEC 61499 standard not only for controller design but also for modeling the system's environment (the "plant"), creating a comprehensive closed-loop model suitable for rigorous verification \cite{xavier2021cyber}. The framework incorporates a seamless toolchain that automates the translation of IEC 61499 designs into a formal representation for a powerful model checker, and provides intuitive tools for analyzing the results \cite{patil2015formal}. Key contributions of this framework include a novel notation for introducing non-determinism into plant models to make verification more realistic and a specific methodology for verifying the correctness of runtime safety monitors \cite{17jhunjhunwala2022monitoring}.

The chapter is structured as follows. Section \ref{sec:iec61499} provides an overview of the IEC 61499 standard. Section \ref{sec:formal_verification} introduces the principles of formal verification and the closed-loop modeling paradigm. Section \ref{sec:toolchain} details the components of the integrated toolchain and the associated methodologies for enhancing verification. Section \ref{sec:case_studies} demonstrates the practical application of the framework through several case studies, from laboratory-scale systems to a safety-critical industrial machine. Finally, Section \ref{sec:conclusion} concludes the chapter and discusses future research directions.

\section{The IEC 61499 Standard for Distributed Automation}\label{sec:iec61499}

The IEC 61499 standard provides a reference architecture for the development of distributed control systems \cite{iec61499}. It was conceived as a successor to the prevalent IEC 61131-3 standard \cite{tiegelkamp1995iec}, moving beyond the limitations of centralized, PLC-centric logic to support the demands of modern, distributed iCPS \cite{zoitl2014}.

At the core of the standard is the Function Block (FB), a reusable software component that encapsulates data and algorithms \cite{drozdov2021}. FBs interact through a well-defined graphical interface consisting of event and data inputs and outputs. The execution of logic within an FB is event-driven; an input event triggers the execution of associated algorithms and may result in the emission of one or more output events, propagating the flow of control through the network \cite{christensen2000design}.

The standard defines several types of FBs, with the most fundamental being the Basic Function Block (BFB). The internal logic of a BFB is defined by an Execution Control Chart (ECC), which is a state machine that dictates the sequence of algorithm execution in response to input events \cite{hanisch2009one}. A Composite Function Block (CFB), in contrast, contains an internal network of other interconnected FBs, enabling hierarchical system design \cite{sonnleithner2021iec}. This component-based, event-driven nature makes IEC 61499 inherently suited for modeling modular, reconfigurable, and distributed systems \cite{patil2018}.

Despite these advantages, the verification of IEC 61499 applications is a recognized challenge \cite{sinha2019survey}. The concurrent and distributed nature of the systems can lead to complex emergent behaviors that are difficult to predict. Furthermore, ambiguities in the standard's original execution semantics led to different interpretations by tool vendors, creating portability and interoperability issues that formal modeling can help to identify and resolve \cite{patil2015neutralizing}.

\section{Formal Verification for IEC 61499 Systems}\label{sec:formal_verification}

Formal verification is the process of using mathematical methods to prove or disprove the correctness of a system with respect to a set of formal specifications \cite{clarke1999}. Model checking is a prominent formal verification technique that automates this process \cite{baier2008}. It operates on a finite-state model of the system, systematically exploring all possible execution paths to check if they satisfy properties expressed in a formal language, such as Linear Temporal Logic (LTL) or Computation Tree Logic (CTL) \cite{emerson1985decision}. If a property is violated, the model checker produces a counterexample—a specific trace of execution that demonstrates the failure \cite{beer2012}.

\subsection{The Closed-Loop Modeling Paradigm}

A crucial aspect of applying model checking effectively to control systems is the adoption of a closed-loop modeling approach \cite{vyatkin2008closed}. Verifying a controller in isolation (open-loop) requires making assumptions about all possible inputs it might receive from its environment, which often leads to an unmanageably large state space and can produce spurious counterexamples that are not possible in the real system \cite{buzhinsky2016plant}.

A closed-loop model, by contrast, includes a formal model of the plant—the physical process or environment the controller interacts with \cite{xavier2021cyber}. This model constrains the inputs to the controller to only those that are physically possible, drastically reducing the reachable state space and leading to more meaningful verification results \cite{xavier2022plant}. This architecture, encompassing both the controller and the plant, allows for the verification of system-level properties that involve interactions between the two \cite{xavier2023formal}.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{chapters/images/chapter2/wholesystem_withhmi.png}
\caption{An illustration of the closed-loop modeling concept, where a controller (or a non-deterministic twin, right) is verified in conjunction with a monitor (left), representing an interconnected system.}
\label{fig:closed_loop}
\end{figure}

\subsection{From Simulation to Verification Models}

The IEC 61499 standard is well-suited for closed-loop modeling because the same component-based language can be used to model both the controller and the plant \cite{vyatkin2003verification}. This allows for a seamless transition from simulation to formal verification \cite{patil2015formal}.

Initially, a detailed plant model, often equivalent to a hybrid automaton with continuous dynamics, can be created for simulation-in-the-loop to test the overall system behavior and provide visualization \cite{vyatkin2008closed}. For formal verification, this detailed model is then abstracted into a simpler, discrete-state model that captures the essential behaviors relevant to the properties being checked, but omits complexities like continuous dynamics that are computationally expensive for model checkers to handle \cite{drozdov2016formal}. This dual-model approach allows engineers to use familiar tools for design and simulation, while enabling a pathway to rigorous formal verification \cite{xavier2022process}.

\section{An Integrated Verification Toolchain and Methodology}\label{sec:toolchain}

To make formal verification practical for automation engineers, a seamless and highly automated toolchain is required \cite{xavier2021}. The framework presented here integrates industry-standard design environments with a powerful open-source model checker, facilitated by a custom model generator and advanced analysis tools \cite{fb2smv}.

\subsection{Overview of the Toolchain}

The proposed workflow connects the design, verification, and analysis phases into a cohesive process.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{chapters/images/chapter2/system_functional_model.png}
\caption{The proposed workflow for the design and validation of safety-critical automation systems, integrating design, simulation, formal model generation, model checking, and counterexample analysis.}
\label{fig:workflow}
\end{figure}

The toolchain consists of the following key components:

\begin{itemize}
\item \textbf{IEC 61499 Design Environment}: The process begins in an IEC 61499-compliant IDE, such as EcoStruxure™ Automation Expert or the open-source Function Blocks Modelling Environment (FBME) \cite{FBME}, where the controller and plant FBs are designed and simulated.

\item \textbf{Formal Model Generator (fb2smv)}: The fb2smv tool automatically translates the IEC 61499 application, described in its standard XML format, into a formal model in the SMV (Symbolic Model Verifier) language \cite{drozdov2021formal}. This tool uses Abstract State Machines (ASM) as an intermediate model to handle the translation of the ECCs, algorithms, and network connections \cite{gurevich1995evolving}.

\item \textbf{Symbolic Model Checker (NuSMV)}: The generated SMV model is fed into NuSMV, an open-source symbolic model checker \cite{Cimatti2002}. NuSMV verifies the model against the specified LTL or CTL properties and, if a violation is found, generates a counterexample trace \cite{nusmv}.

\item \textbf{Counterexample Analysis Environment (FBME)}: Analyzing the raw text output of a model checker can be difficult and unintuitive \cite{Ovsiannikova2021}. Tools like FBME have been enhanced with trace visualization capabilities that import the counterexample from NuSMV and map it back onto the original graphical IEC 61499 model \cite{liakh2022formal}. This allows engineers to step through the failure trace visually, see the state of ECCs and variable values at each step, and use causal analysis to pinpoint the root cause of the error.
\end{itemize}

\subsection{Enhancing Plant Models with Non-Deterministic Transitions (NDT)}

A key challenge in creating abstracted plant models for verification is ensuring they are realistic enough to capture potential failures \cite{patil2011closed}. A purely deterministic model, where an action takes a fixed amount of time, may fail to uncover timing-related bugs, such as collisions that occur only when one axis moves faster or slower than another \cite{patil2015counterexample}.

To address this, this framework introduces a problem-oriented notation for Non-Deterministic Transitions (NDT) directly within the ECC of an IEC 61499 plant model \cite{xavier2021cyber}. An NDT represents a transition that can fire at an arbitrary time after it becomes enabled. For example, in a model of a linear axis, an NDT can be used to model the unknown duration of the motion between two points \cite{toolchain}.

\begin{figure}[h]
\centering
\includegraphics[width=0.7\textwidth]{chapters/images/chapter2/ECC-moniteur.png}
\caption{An example ECC for an elevator plant model. The transition from the GO state to the END state is triggered by an NDT event, modeling an unspecified amount of time for the motion to complete.}
\label{fig:ecc_ndt}
\end{figure}

When the fb2smv tool encounters an NDT event, it translates it into a non-deterministic choice in the SMV model \cite{drozdov2016formal}. This instructs the model checker to explore all possible timings for that transition, effectively simulating a wide range of real-world scenarios (e.g., different relative speeds between concurrent movements) and enabling the detection of subtle, timing-dependent design flaws that would be difficult to find through simulation alone \cite{patil2015counterexample}. This ability to govern and selectively inject non-determinism is a powerful feature for performing targeted formal verification under specific stress conditions \cite{patil2011closed}.

\subsection{A Methodology for Verifying Runtime Monitors}

In addition to offline verification at the design stage, many safety-critical systems utilize online verification through runtime monitors \cite{17jhunjhunwala2022monitoring}. These monitors, often implemented as FBs themselves, observe the system during operation and signal an error if a safety property is violated \cite{1falcone2022runtime}. However, a monitor only improves system safety if its own correctness is guaranteed \cite{9wiesmayr2022supporting}.

Verifying a monitor presents a unique challenge \cite{15blech2016comparison}. Traditional open-loop model checking, where the monitor's inputs are allowed to change arbitrarily, will often produce spurious counterexamples \cite{12yoong2010verifying}. This is because it allows input combinations that are semantically impossible in a real IEC 61499 system, such as data being transferred without a corresponding event firing \cite{13yoong2015verification}.

To solve this, a methodology is proposed for the closed-loop model checking of monitors using a non-deterministic twin (ND twin) of the controller it supervises \cite{17jhunjhunwala2022monitoring}. The ND twin is a simplified FB that abstracts the controller's logic but is designed to produce every possible valid combination of its outputs. It achieves this by using NDTs to allow arbitrary transitions between its key states (e.g., EXTEND, RETRACT, STOP) \cite{toolchain}.

By connecting the monitor to this ND twin, the model checker can exhaustively test the monitor's logic against all valid controller behaviors \cite{nusmv}. The verification is then guided by two main properties:

\begin{enumerate}
\item The monitor must report a failure when a failure actually occurs. (e.g., G ((m.hext ∧ m.vext) → (m.hext ∧ m.vext U m.collision)))
\item The monitor must not report a spurious failure when the controller is functioning as expected. (e.g., G (¬(m.hext ∧ m.vext) → F ¬m.collision))
\end{enumerate}

This approach ensures that the monitor is trustworthy before it is deployed for online verification, forming a critical link between offline design-time checks and online runtime safety assurance \cite{17jhunjhunwala2022monitoring}.

\section{Application to Case Studies}\label{sec:case_studies}

The effectiveness of the proposed framework and methodologies has been demonstrated on several case studies, ranging from laboratory-scale systems to real-world safety-critical applications \cite{xavier2023formal}.

\subsection{System of Two Pneumatic Cylinders}

This system involves two orthogonal pneumatic cylinders that must move without colliding \cite{17jhunjhunwala2022monitoring}. A runtime monitor, NoCollisionMonitor, was implemented as a BFB to ensure this safety property holds during operation. To verify the monitor, an ND twin of the cylinder controller was created. The ND twin was designed to non-deterministically produce EXTEND, RETRACT, and STOP commands, allowing it to generate the collision scenario (EXTEND from both twins simultaneously) as well as all non-collision scenarios. Using NuSMV, the monitor was successfully verified against the two key properties: it correctly reported the collision when it occurred and did not report false positives, proving its reliability \cite{nusmv}.

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{chapters/images/chapter2/2cylindre_hmi.JPG}
\caption{The two pneumatic cylinder system with HMI interface, demonstrating the collision detection and prevention mechanism.}
\label{fig:two_cylinders}
\end{figure}

\subsection{Drilling Station}

This case study features a drilling station with a drill and a rotating table \cite{fb2smv}. The control logic, implemented in IEC 61499, was designed to prevent the table from rotating while the drill is active. The system was modeled in a closed loop, with NDTs used in the plant models for the drill and table to represent the unknown duration of their movements \cite{drozdov2016formal}. During model checking with NuSMV, a CTL specification G !(DrillCTL\_RET = TRUE \& ActuatorGen\_EO = TRUE) (the table cannot rotate while drilling) was found to be false \cite{emerson1985decision}. The model checker generated a counterexample trace which, after analysis, revealed a flaw in the table controller's ECC that failed to check for a blocking signal before initiating rotation. After fixing the logic and re-running the verification, the property was satisfied, demonstrating the toolchain's ability to find and help correct non-trivial design errors \cite{patil2015counterexample}.

\subsection{Safety-Critical Horizontal Handling Machine (HHM)}

The framework was applied to the refactoring and verification of the control software for the HHM, a remote handling robot used to transport highly radioactive material at the SPES nuclear research facility \cite{Marchietal.2020}. The original control software, based on IEC 61131, was redesigned using a modular IEC 61499 architecture \cite{zoitl2014}.

A critical safety requirement is to prevent mechanical collisions between the machine's axes \cite{khan2014}. To test this, a design flaw was deliberately introduced into the controller's FSM, changing a sequence of three axis movements from sequential to parallel execution. This type of error is hard to detect via simulation, as a collision may or may not occur depending on the relative speeds of the axes \cite{patil2015counterexample}.

The plant models for the linear axes were created with NDTs to model variable movement times \cite{xavier2021cyber}. The entire closed-loop system was translated to SMV and verified with NuSMV \cite{fb2smv}. The model checker successfully found a violation of the LTL specification designed to prevent collisions \cite{emerson1985decision}. The resulting counterexample trace was imported into FBME for analysis \cite{liakh2022formal}.

\begin{figure}[h]
\centering
\includegraphics[width=0.9\textwidth]{chapters/images/chapter2/vizu_jumeauV1.png}
\caption{Analysis of the NuSMV counterexample trace in the FBME environment. The tool visualizes the system state at each step, highlights changes in the graphical FB network, and allows for causal analysis to trace the error back to its source.}
\label{fig:counterexample_analysis}
\end{figure}

The visual trace analysis in FBME made it possible to step through the failure scenario and clearly identify how the parallel execution, under a specific timing sequence explored by NuSMV due to the NDTs, led to the collision \cite{Ovsiannikova2021}. This case study demonstrates the scalability and practical value of the integrated toolchain in ensuring the safety of complex, real-world industrial systems \cite{xavier2023formal}.

\section{Conclusion and Future Outlook}\label{sec:conclusion}

This chapter presented an integrated framework for the model-based design and formal verification of iCPS developed with the IEC 61499 standard \cite{xavier2021cyber}. By combining a seamless toolchain with advanced modeling methodologies, the framework makes the power of formal verification more accessible to automation engineers, enabling the early detection of subtle and critical design flaws that traditional testing methods may miss \cite{patil2015formal}.

The main contributions are threefold. First, the integrated toolchain provides a practical workflow from design and simulation in standard IDEs to automated formal model generation (fb2smv) \cite{fb2smv}, verification (NuSMV) \cite{Cimatti2002}, and intuitive counterexample analysis (FBME) \cite{liakh2022formal}. Second, the proposed notation for Non-Deterministic Transitions (NDT) within IEC 61499 plant models allows for the creation of more realistic verification models that can uncover timing-dependent bugs \cite{xavier2021cyber}. Third, the methodology for verifying runtime monitors using a non-deterministic twin of the controller ensures that online safety mechanisms are themselves reliable \cite{17jhunjhunwala2022monitoring}.

The application of this framework to multiple case studies, including a safety-critical nuclear handling system \cite{Marchietal.2020}, has validated its effectiveness in improving the dependability of complex distributed automation systems \cite{xavier2023formal}. By lowering the barrier to entry for formal methods, this work contributes to building more robust, reliable, and safer industrial systems \cite{clarke1999}.

Future work will focus on extending the framework's capabilities \cite{xavier2022interactive}. This includes automating the generation of ND twins for monitor verification and further exploring the scalability of the approach for even larger systems \cite{xavier2022plant}. Another promising direction is the extension of the modeling notation and toolchain to support timed automata, which would allow for the verification of quantitative real-time properties, moving beyond the current focus on logical correctness and untimed non-determinism \cite{Time-AwareComputations1}. Finally, automatically generating specifications from informal requirements and generating plant models from system data logs are active research areas that could further enhance the automation and power of the verification process \cite{xavier2022process}.
